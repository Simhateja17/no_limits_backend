// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  engineType = "library"
}

datasource db {
  provider = "postgresql"
}

// ==================== ENUMS ====================

// User role enumeration
enum UserRole {
  CLIENT      // Shopify/WooCommerce store owner (Customer/Tenant)
  EMPLOYEE    // Warehouse employee
  ADMIN       // Warehouse owner (secret login)
  SUPER_ADMIN // Super admin with full access
}

// Channel/Shop platform types
enum ChannelType {
  SHOPIFY
  WOOCOMMERCE
  AMAZON
  EBAY
  OTHER
}

// Channel status
enum ChannelStatus {
  ACTIVE
  INACTIVE
  PENDING
  ERROR
}

// Order status
enum OrderStatus {
  PENDING
  PROCESSING
  IN_STOCK
  OUT_OF_STOCK
  PARTIALLY_FULFILLED
  SHIPPED
  DELIVERED
  CANCELLED
  ON_HOLD
  ERROR
}

// Inbound delivery status
enum InboundStatus {
  PENDING
  PARTIALLY_BOOKED_IN
  BOOKED_IN
  CANCELLED
}

// Inbound delivery type
enum DeliveryType {
  FREIGHT_FORWARDER
  PARCEL_SERVICE
  SELF_DELIVERY
  OTHER
}

// Return status
enum ReturnStatus {
  ANNOUNCED       // Return announced to JTL-FFN
  RECEIVED        // Warehouse received the return
  CHECKING        // Being inspected
  CHECKED         // Inspection complete
  PROCESSED       // Return fully processed
  RESTOCKED       // Items returned to inventory
  NOT_RESTOCKED   // Items disposed/not returned to inventory
  UNKNOWN         // Unknown return (needs admin review)
  COMPLETED
}

// Product condition for returns
enum ProductCondition {
  GOOD
  ACCEPTABLE
  DAMAGED
  DEFECTIVE
}

// Return item disposition
enum ReturnDisposition {
  DISPOSED
  BOOKED_IN_AGAIN
  PENDING_DECISION
}

// Task status
enum TaskStatus {
  OPEN
  IN_PROGRESS
  COMPLETED
  CLOSED
  CANCELLED
}

// Task priority
enum TaskPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

// Task type
enum TaskType {
  INTERNAL_WAREHOUSE
  CLIENT_COMMUNICATION
  ORDER_PROCESSING
  RETURNS
  INVENTORY_CHECK
  OTHER
}

// Chat message status
enum MessageStatus {
  SENT
  DELIVERED
  READ
  ERROR
  PENDING_APPROVAL  // For warehouse free-text messages
}

// Billing status
enum BillingStatus {
  PAID
  UNPAID
  OVERDUE
  PENDING
}

// Quotation status
enum QuotationStatus {
  DRAFT
  PENDING
  SENT
  ACCEPTED
  REJECTED
  EXPIRED
}

// ==================== MODELS ====================

// User model with role-based access
model User {
  id            String    @id @default(cuid())
  email         String    @unique
  password      String
  name          String?
  role          UserRole  @default(CLIENT)
  isActive      Boolean   @default(true)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  lastLoginAt   DateTime?
  avatar        String?
  phone         String?
  
  // Employee-specific fields
  employeeId    String?
  department    String?
  
  // Relations
  client        Client?   @relation("ClientUser")
  
  // Chat relations
  sentMessages      ChatMessage[]     @relation("SentMessages")
  chatParticipants  ChatParticipant[]
  
  // Task relations
  assignedTasks     Task[]            @relation("AssignedTasks")
  createdTasks      Task[]            @relation("CreatedTasks")
  
  // Audit logs
  auditLogs         AuditLog[]
  
  // Return processing
  processedReturns  Return[]          @relation("ProcessedBy")

  // Notifications
  notifications     Notification[]

  // Task messages (for task-specific chat)
  taskMessages      TaskMessage[]

  @@map("users")
}

// Client/Customer/Tenant - Multi-tenancy support
model Client {
  id                        String        @id @default(cuid())
  name                      String
  companyName               String
  email                     String        @unique
  phone                     String?
  address                   String?
  city                      String?
  zipCode                   String?
  country                   String?
  
  // Billing information
  billingStatus             BillingStatus @default(PENDING)
  lastBillingPeriod         String?
  totalValue                Decimal?      @db.Decimal(12, 2)
  
  // Default shipping method (fallback when order shipping method is unmapped)
  defaultShippingMethodId   String?
  defaultShippingMethod     ShippingMethod? @relation("DefaultShippingMethod", fields: [defaultShippingMethodId], references: [id])
  
  // Status
  isActive                  Boolean       @default(true)
  createdAt                 DateTime      @default(now())
  updatedAt                 DateTime      @updatedAt
  
  // User relation (one-to-one with CLIENT role user)
  userId                    String        @unique
  user                      User          @relation("ClientUser", fields: [userId], references: [id], onDelete: Cascade)
  
  // Relations - Multi-tenant isolation
  channels                  Channel[]
  products                  Product[]
  orders                    Order[]
  inbounds                  InboundDelivery[]
  returns                   Return[]
  quotations                Quotation[]
  chatRoom                  ChatRoom?
  jtlConfig                 JtlConfig?
  shippingMethodMappings    ShippingMethodMapping[] @relation("ClientShippingMappings")
  notifications             Notification[]
  tasks                     Task[]
  
  @@map("clients")
}

// JTL-FFN API Configuration
model JtlConfig {
  id              String    @id @default(cuid())
  
  // OAuth credentials
  clientId        String
  clientSecret    String    // Stored encrypted
  accessToken     String?   // Stored encrypted
  refreshToken    String?   // Stored encrypted
  tokenExpiresAt  DateTime?
  
  // Fulfiller and warehouse IDs
  fulfillerId     String
  warehouseId     String
  
  // Environment
  environment     String    @default("sandbox") // 'sandbox' or 'production'
  
  // Status
  isActive        Boolean   @default(true)
  lastSyncAt      DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  // Relation
  clientId_fk     String    @unique @map("client_id")
  client          Client    @relation(fields: [clientId_fk], references: [id], onDelete: Cascade)
  
  @@map("jtl_configs")
}

// Temporary Shopify OAuth Configuration (for OAuth flow)
model ShopifyOAuthConfig {
  id                  String    @id @default(cuid())
  clientId            String
  shopDomain          String
  oauthClientId       String    // Shopify App Client ID
  oauthClientSecret   String    // Stored encrypted
  oauthNonce          String?   // Cryptographic nonce for CSRF protection
  oauthNonceExpiry    DateTime? // Expiry time for the nonce (typically 15 minutes)
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  @@unique([clientId, shopDomain], name: "clientId_shopDomain")
  @@map("shopify_oauth_configs")
}

// Quotation model
model Quotation {
  id                  String           @id @default(cuid())
  quotationNumber     String           @unique
  
  // Client relation
  clientId_fk         String           @map("client_id")
  client              Client           @relation(fields: [clientId_fk], references: [id], onDelete: Cascade)
  
  // Quotation details
  validUntil          DateTime?
  subtotal            Decimal          @db.Decimal(12, 2)
  tax                 Decimal          @db.Decimal(12, 2)
  total               Decimal          @db.Decimal(12, 2)
  
  // Additional info
  notes               String?
  termsAndConditions  String?
  
  // Status
  status              QuotationStatus  @default(PENDING)
  
  // Timestamps
  sentAt              DateTime?
  acceptedAt          DateTime?
  rejectedAt          DateTime?
  createdAt           DateTime         @default(now())
  updatedAt           DateTime         @updatedAt
  
  // Relations
  items               QuotationItem[]
  
  @@map("quotations")
}

// Quotation items
model QuotationItem {
  id            String     @id @default(cuid())
  
  // Quotation relation
  quotationId   String     @map("quotation_id")
  quotation     Quotation  @relation(fields: [quotationId], references: [id], onDelete: Cascade)
  
  // Item details
  description   String
  quantity      Int
  unitPrice     Decimal    @db.Decimal(10, 2)
  total         Decimal    @db.Decimal(12, 2)
  
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt
  
  @@map("quotation_items")
}

// Sales Channel (Shop Integration)
model Channel {
  id              String        @id @default(cuid())
  name            String
  type            ChannelType
  status          ChannelStatus @default(PENDING)
  url             String?

  // Shopify-specific settings
  shopDomain      String?       // Shopify shop domain (e.g., mystore.myshopify.com)

  // Authentication method tracking
  authMethod      String?       // "custom_app", "shared_oauth", "client_oauth"

  // API Credentials (encrypted in application layer)
  apiClientId     String?       // API Client ID from platform
  apiClientSecret String?       // Stored encrypted
  accessToken     String?       // Stored encrypted
  refreshToken    String?       // Stored encrypted
  tokenExpiresAt  DateTime?

  // OAuth state management for CSRF protection
  oauthState      String?       // Temporary CSRF protection token
  oauthStateExpiry DateTime?    // State expiration timestamp (15 min)

  // API Settings
  apiUrl          String?
  webhookUrl      String?
  webhookSecret   String?

  // Shipping settings
  defaultShippingMethod String?

  // Location settings
  warehouseLocation String?

  // Sync settings
  lastSyncAt      DateTime?
  lastOrderPollAt   DateTime?   // Last successful cron poll for orders
  lastProductPollAt DateTime?   // Last successful cron poll for products
  syncEnabled     Boolean       @default(true)
  isActive        Boolean       @default(true)

  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // Relations
  clientId        String        @map("client_id")
  client          Client        @relation(fields: [clientId], references: [id], onDelete: Cascade)

  orders          Order[]
  products        ProductChannel[]
  syncJobs        SyncJob[]
  shippingMethodMappings ShippingMethodMapping[] @relation("ChannelShippingMappings")
  syncPipelines   SyncPipeline[]

  @@unique([clientId, shopDomain, type])
  @@map("channels")
}

// Sync Job tracking for real-time status updates
model SyncJob {
  id              String        @id @default(cuid())
  channelId       String        @map("channel_id")
  channel         Channel       @relation(fields: [channelId], references: [id], onDelete: Cascade)
  
  // Job status
  status          SyncJobStatus @default(PENDING)
  type            String        @default("initial") // "initial", "incremental", "full", "INITIAL_QUICK", "INITIAL_FULL"

  // Progress tracking
  totalProducts   Int           @default(0)
  syncedProducts  Int           @default(0)
  failedProducts  Int           @default(0)
  totalOrders     Int           @default(0)
  syncedOrders    Int           @default(0)
  failedOrders    Int           @default(0)
  totalReturns    Int           @default(0)
  syncedReturns   Int           @default(0)
  failedReturns   Int           @default(0)

  // Current phase
  currentPhase    String?       // "products", "orders", "returns", "completed", "quick_sync", "quick_sync_done", "background_sync", "parallel"
  
  // Error tracking
  errorMessage    String?
  
  // Timestamps
  startedAt       DateTime      @default(now())
  completedAt     DateTime?
  
  @@map("sync_jobs")
}

enum SyncJobStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED
}

// Origin of the last update for sync tracking
enum SyncOrigin {
  NOLIMITS      // Created/edited in No-Limits platform
  SHOPIFY       // Created/edited in Shopify
  WOOCOMMERCE   // Created/edited in WooCommerce
  JTL           // Created/edited in JTL-FFN
  SYSTEM        // System-generated update
  WAREHOUSE     // Created in warehouse (e.g., unknown return)
}

// Sync status for individual entities
enum SyncStatus {
  SYNCED        // All platforms in sync
  PENDING       // Sync pending
  CONFLICT      // Manual resolution needed
  ERROR         // Sync error
  SKIPPED       // Sync skipped (e.g., stress test orders)
}

// Fulfillment state for orders (Operational truth = No-Limits platform)
enum FulfillmentState {
  PENDING              // Initial state - maps to FFN 'pending'
  PREPARATION          // Order being prepared - maps to FFN 'preparation'
  ACKNOWLEDGED         // Order acknowledged by FFN - maps to FFN 'acknowledged'
  LOCKED               // Order locked for processing - maps to FFN 'locked'
  PICKPROCESS          // Items being picked - maps to FFN 'pickprocess'
  SHIPPED              // Order shipped - maps to FFN 'shipped'
  PARTIALLY_SHIPPED    // Partial shipment - maps to FFN 'partiallyShipped'
  CANCELED             // Order canceled - maps to FFN 'canceled'
  PARTIALLY_CANCELED   // Partial cancellation - maps to FFN 'partiallyCanceled'
  IN_TRANSIT           // In transit to customer (post-FFN tracking)
  DELIVERED            // Successfully delivered (post-FFN tracking)
  FAILED_DELIVERY      // Delivery failed (post-FFN tracking)
  RETURNED_TO_SENDER   // Package returned (post-FFN tracking)
}

// Return inspection result
enum InspectionResult {
  PENDING             // Not yet inspected
  RESTOCKED           // Items can be returned to inventory
  DAMAGED             // Items damaged, cannot restock
  DEFECTIVE           // Items defective, cannot restock
  WRONG_ITEM          // Wrong item received
  REJECTED            // Return rejected (fraud, etc.)
  PARTIAL_RESTOCK     // Some items restocked, some not
}

// Product/Article
model Product {
  id              String    @id @default(cuid())
  productId       String    // External product ID
  name            String
  description     String?
  
  // Product identification
  sku             String
  gtin            String?   // Global Trade Item Number (barcode)
  amazonAsin      String?
  amazonSku       String?
  isbn            String?
  han             String?   // Manufacturer Article Number
  
  // Stock levels (shared across all shops of a customer)
  available       Int       @default(0)
  reserved        Int       @default(0)
  announced       Int       @default(0)  // Expected from inbound deliveries
  
  // Product dimensions
  heightInCm      Decimal?  @db.Decimal(10, 2)
  lengthInCm      Decimal?  @db.Decimal(10, 2)
  widthInCm       Decimal?  @db.Decimal(10, 2)
  weightInKg      Decimal?  @db.Decimal(10, 3)
  
  // Product properties
  mhd             DateTime? // Best before date
  chargeNumber    String?   // Batch/Lot number
  customsCode     String?   // Zolltarifnummer
  countryOfOrigin String?
  netSalesPrice   Decimal?  @db.Decimal(12, 2)
  manufacturer    String?
  
  // Commerce-owned fields (Shopify/WooCommerce authoritative)
  compareAtPrice  Decimal?  @db.Decimal(12, 2) // Original price for sales
  taxable         Boolean   @default(true)
  seoTitle        String?
  seoDescription  String?
  tags            String[]  @default([])
  collections     String[]  @default([])       // Category/collection IDs
  productType     String?
  vendor          String?
  
  // Ops/Warehouse-owned fields (No-Limits authoritative)
  packagingUnit   String?   // e.g., "piece", "box", "pallet"
  packagingQty    Int       @default(1)        // Items per packaging unit
  hazmat          Boolean   @default(false)    // Hazardous material flag
  hazmatClass     String?                      // Hazmat classification
  warehouseNotes  String?                      // Internal warehouse notes
  storageLocation String?                      // Preferred storage location
  minStockLevel   Int       @default(0)        // Minimum stock threshold
  reorderPoint    Int       @default(0)        // Reorder trigger level
  
  // Images
  imageUrl        String?
  images          ProductImage[]
  
  // Bundle support
  isBundle        Boolean   @default(false)
  bundlePrice     Decimal?  @db.Decimal(12, 2)

  // Status
  isActive        Boolean   @default(true)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // ===== SYNC TRACKING =====
  // Origin tracking - prevents infinite sync loops
  lastUpdatedBy     SyncOrigin  @default(NOLIMITS)   // Who made the last change
  lastSyncedAt      DateTime?                        // When last synced to all platforms
  syncStatus        SyncStatus  @default(PENDING)    // Current sync status
  syncChecksum      String?                          // Hash of synced fields for change detection
  
  // Field-level tracking (JSON storing which platform owns which fields)
  fieldOwnership    Json?       // { "price": "shopify", "weight": "nolimits", ... }
  lastFieldUpdates  Json?       // { "price": { "by": "shopify", "at": "2025-01-01T..." }, ... }
  
  // JTL-FFN integration
  jtlProductId    String?   // JTL-FFN external ID (JFSKU)
  jtlArticleId    String?   // JTL-FFN article ID
  lastJtlSync     DateTime?
  jtlSyncStatus   SyncStatus  @default(PENDING)
  
  // Relations
  clientId        String    @map("client_id")
  client          Client    @relation(fields: [clientId], references: [id], onDelete: Cascade)
  
  channels        ProductChannel[]
  orderItems      OrderItem[]
  inboundItems    InboundItem[]
  returnItems     ReturnItem[]
  syncLogs        ProductSyncLog[]
  syncQueue       ProductSyncQueue[]
  bundleItems       BundleItem[]  @relation("BundleParent")
  bundledInProducts BundleItem[]  @relation("BundleChild")
  pendingBundleLinks  PendingBundleLink[] @relation("PendingBundleParent")

  @@unique([clientId, sku])
  @@index([syncStatus])
  @@index([lastUpdatedBy])
  @@map("products")
}

// Bundle Item - Join table for product bundles (Bill of Materials)
model BundleItem {
  id              String    @id @default(cuid())
  quantity        Int       @default(1)
  parentProductId String    @map("parent_product_id")
  parentProduct   Product   @relation("BundleParent", fields: [parentProductId], references: [id], onDelete: Cascade)
  childProductId  String    @map("child_product_id")
  childProduct    Product   @relation("BundleChild", fields: [childProductId], references: [id], onDelete: Cascade)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@unique([parentProductId, childProductId])
  @@index([childProductId])
  @@map("bundle_items")
}

// Pending Bundle Link - Deferred bundle linking when child products don't exist yet
model PendingBundleLink {
  id                  String   @id @default(cuid())

  // Parent bundle product
  parentProductId     String   @map("parent_product_id")
  parentProduct       Product  @relation("PendingBundleParent", fields: [parentProductId], references: [id], onDelete: Cascade)

  // Child identification (may not exist yet)
  childExternalId     String?  // External platform ID (e.g., Shopify variant ID)
  childSku            String?  // SKU fallback

  // Resolved child (once found)
  childProductId      String?  @map("child_product_id")

  quantity            Int      @default(1)
  channelId           String   @map("channel_id")
  status              String   @default("pending") // "pending" | "resolved" | "failed"

  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  @@index([childSku])
  @@index([childExternalId])
  @@index([parentProductId])
  @@index([status])
  @@map("pending_bundle_links")
}

// Product Sync Log - Audit trail for all sync operations
model ProductSyncLog {
  id              String      @id @default(cuid())
  
  // What changed
  action          String      // "create", "update", "delete", "conflict"
  origin          SyncOrigin  // Where the change came from
  targetPlatform  String      // Where we synced to: "shopify", "woocommerce", "jtl"
  
  // Change details
  changedFields   String[]    @default([])  // List of fields that changed
  oldValues       Json?                     // Previous field values
  newValues       Json?                     // New field values
  
  // Result
  success         Boolean     @default(true)
  errorMessage    String?
  externalId      String?     // ID on the target platform
  
  // Timestamps
  createdAt       DateTime    @default(now())
  
  // Relations
  productId       String      @map("product_id")
  product         Product     @relation(fields: [productId], references: [id], onDelete: Cascade)
  
  @@index([productId, createdAt])
  @@index([origin, targetPlatform])
  @@map("product_sync_logs")
}

// Product Sync Queue - Async job queue for sync operations
model ProductSyncQueue {
  id              String      @id @default(cuid())
  
  // Job details
  operation       String      // "push_to_shopify", "push_to_woocommerce", "push_to_jtl"
  priority        Int         @default(0)   // Higher = more urgent
  
  // Origin tracking for loop prevention
  triggerOrigin   SyncOrigin  // What triggered this sync
  triggerEventId  String?     // External event ID (e.g., webhook ID)
  
  // Payload
  payload         Json?       // Additional data needed for the sync
  fieldsToSync    String[]    @default([])  // Specific fields to sync (empty = all applicable)
  
  // Processing state
  status          String      @default("pending") // "pending", "processing", "completed", "failed", "skipped"
  attempts        Int         @default(0)
  maxAttempts     Int         @default(3)
  lastError       String?
  
  // Timestamps
  scheduledFor    DateTime    @default(now())  // When to process this job
  startedAt       DateTime?
  completedAt     DateTime?
  createdAt       DateTime    @default(now())
  
  // Relations
  productId       String      @map("product_id")
  product         Product     @relation(fields: [productId], references: [id], onDelete: Cascade)
  
  channelId       String?     @map("channel_id")
  
  @@index([status, scheduledFor])
  @@index([productId, status])
  @@index([status, priority, scheduledFor])  // For efficient priority-based ordering
  @@map("product_sync_queue")
}

// Order sync queue - for pushing orders to JTL FFN
model OrderSyncQueue {
  id              String      @id @default(cuid())

  // Job details
  operation       String      // "push_to_jtl"
  priority        Int         @default(0)

  // Origin tracking
  triggerOrigin   SyncOrigin
  triggerEventId  String?

  // Payload
  payload         Json?

  // Processing state
  status          String      @default("pending") // "pending", "processing", "completed", "failed", "skipped"
  attempts        Int         @default(0)
  maxAttempts     Int         @default(3)
  lastError       String?

  // Timestamps
  scheduledFor    DateTime    @default(now())
  startedAt       DateTime?
  completedAt     DateTime?
  createdAt       DateTime    @default(now())

  // Relations
  orderId         String      @map("order_id")
  order           Order       @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@index([status, scheduledFor])
  @@index([orderId, status])
  @@map("order_sync_queue")
}

// Product images
model ProductImage {
  id          String    @id @default(cuid())
  url         String
  altText     String?
  sortOrder   Int       @default(0)
  createdAt   DateTime  @default(now())
  
  productId   String    @map("product_id")
  product     Product   @relation(fields: [productId], references: [id], onDelete: Cascade)
  
  @@map("product_images")
}

// Product-Channel relationship (for multi-channel sync)
model ProductChannel {
  id                String      @id @default(cuid())
  externalProductId String?     // Product ID in the external platform
  externalVariantId String?     // Variant ID (for Shopify variants)
  isActive          Boolean     @default(true)
  syncEnabled       Boolean     @default(true)
  lastSyncAt        DateTime?
  
  // Sync tracking per channel
  syncStatus        SyncStatus  @default(PENDING)
  lastSyncChecksum  String?     // Hash of last synced data
  lastError         String?
  lastErrorAt       DateTime?
  
  // Platform-specific metadata
  platformData      Json?       // Store platform-specific fields
  
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
  
  productId         String      @map("product_id")
  product           Product     @relation(fields: [productId], references: [id], onDelete: Cascade)
  
  channelId         String      @map("channel_id")
  channel           Channel     @relation(fields: [channelId], references: [id], onDelete: Cascade)
  
  @@unique([productId, channelId])
  @@index([syncStatus])
  @@map("product_channels")
}

// Order
model Order {
  id                  String      @id @default(cuid())
  orderId             String      // Display order ID
  orderNumber         String?     // Human-readable order number (e.g., #1001)
  externalOrderId     String?     // Order ID from external platform
  
  // ===== AUTHORITY & ORIGIN TRACKING =====
  // Commercial truth = Shopify/WooCommerce (order born at checkout)
  // Operational truth = No-Limits Platform
  orderOrigin         SyncOrigin  @default(SHOPIFY)      // Where order was created (always commerce platform)
  orderState          OrderStatus @default(PENDING)       // Commercial state from origin
  fulfillmentState    FulfillmentState @default(PENDING)  // Operational state (No-Limits owns)
  lastOperationalUpdateBy SyncOrigin @default(NOLIMITS)   // Who made last operational change
  lastOperationalUpdateAt DateTime?                       // When last operational change was made
  
  // Order details
  orderDate           DateTime    @default(now())
  status              OrderStatus @default(PENDING)
  
  // ===== OPERATIONAL FIELDS (No-Limits Owned) =====
  // These fields can be edited in No-Limits and synced to FFN/Shopify
  warehouseNotes      String?                             // Internal warehouse notes
  carrierSelection    String?                             // Selected carrier (e.g., "DHL", "UPS")
  carrierServiceLevel String?                             // Service level (e.g., "EXPRESS", "STANDARD")
  priorityLevel       Int         @default(0)             // Processing priority (higher = more urgent)
  pickingInstructions String?                             // Special picking instructions
  packingInstructions String?                             // Special packing instructions
  
  // Address corrections (before fulfillment)
  addressCorrected    Boolean     @default(false)
  addressCorrectedAt  DateTime?
  originalShippingAddress Json?                           // Store original address before correction
  
  // Order splits (parent/child tracking)
  isSplitOrder        Boolean     @default(false)
  splitFromOrderId    String?     @map("split_from_order_id")
  splitFromOrder      Order?      @relation("OrderSplits", fields: [splitFromOrderId], references: [id])
  splitOrders         Order[]     @relation("OrderSplits")
  
  // Shipping information
  shippingMethod            String?   // Human-readable shipping method from order
  shippingMethodCode        String?   // Machine-readable code (e.g., "flat_rate", "free_shipping")
  jtlShippingMethodId       String?   // Resolved JTL FFN shipping method ID (e.g., "FULF0A0001")
  shippingMethodMismatch    Boolean   @default(false) // Flag: shipping method could not be resolved
  shippingMethodFallback    Boolean   @default(false) // Flag: using client's default shipping method
  trackingNumber            String?
  shippedAt                 DateTime?
  deliveredAt               DateTime?
  
  // Weight and quantity
  totalWeight         Decimal?    @db.Decimal(10, 3)
  totalQuantity       Int         @default(0)
  
  // ===== COMMERCIAL FIELDS (Shopify/WooCommerce Owned - Read-Only) =====
  // These fields are owned by the commerce platform
  subtotal            Decimal?    @db.Decimal(12, 2)
  shippingCost        Decimal?    @db.Decimal(12, 2)
  tax                 Decimal?    @db.Decimal(12, 2)
  total               Decimal?    @db.Decimal(12, 2)
  currency            String      @default("EUR")
  discountCode        String?
  discountAmount      Decimal?    @db.Decimal(12, 2)
  paymentStatus       String?                             // "paid", "pending", "refunded"
  paymentMethod       String?                             // "credit_card", "paypal", etc.
  
  // Customer information (Commerce-owned)
  customerName        String?
  customerEmail       String?
  customerPhone       String?
  
  // Shipping address
  shippingFirstName   String?
  shippingLastName    String?
  shippingCompany     String?
  shippingAddress1    String?
  shippingAddress2    String?
  shippingCity        String?
  shippingZip         String?
  shippingCountry     String?
  shippingCountryCode String?
  
  // Billing address
  billingFirstName    String?
  billingLastName     String?
  billingCompany      String?
  billingAddress1     String?
  billingAddress2     String?
  billingCity         String?
  billingZip          String?
  billingCountry      String?
  
  // Order notes
  notes               String?                             // Customer notes (from commerce platform)
  tags                String[]    @default([])
  
  // Flags
  isOnHold            Boolean     @default(false)
  holdReason          String?                             // AWAITING_PAYMENT, HIGH_RISK_OF_FRAUD, INCORRECT_ADDRESS, INVENTORY_OUT_OF_STOCK, OTHER
  holdNotes           String?                             // Additional notes for hold reason
  holdPlacedAt        DateTime?                           // When the hold was placed
  holdPlacedBy        String?                             // User ID who placed the hold
  holdReleasedAt      DateTime?                           // When the hold was released
  holdReleasedBy      String?                             // User ID who released the hold
  paymentHoldOverride Boolean     @default(false)         // Client manually released payment hold â€” allows FFN sync despite unpaid status
  trackingUrl         String?                             // Full tracking URL

  isReplacement       Boolean     @default(false)
  isCancelled         Boolean     @default(false)
  cancelledAt         DateTime?
  cancelledBy         SyncOrigin?                         // Who cancelled the order
  cancellationReason  String?
  
  // Replacement order reference
  originalOrderId     String?     @map("original_order_id")
  originalOrder       Order?      @relation("ReplacementOrders", fields: [originalOrderId], references: [id])
  replacementOrders   Order[]     @relation("ReplacementOrders")
  
  // ===== SYNC TRACKING =====
  syncStatus          SyncStatus  @default(PENDING)
  lastSyncedToFfn     DateTime?
  lastSyncedToCommerce DateTime?
  ffnSyncError        String?
  commerceSyncError   String?
  
  // JTL-FFN integration
  jtlOrderId          String?     // Legacy - kept for backward compatibility
  jtlOutboundId       String?     // JTL-FFN Outbound ID
  jtlFulfillmentId    String?     // JTL-FFN Fulfillment order ID
  lastJtlSync         DateTime?

  // ===== SHOPIFY FULFILLMENT ORDER TRACKING =====
  // Used for the Shopify FulfillmentOrder API and 3PL flow
  shopifyFulfillmentOrderId        String?    // Shopify FulfillmentOrder GID
  shopifyFulfillmentOrderStatus    String?    // OPEN, IN_PROGRESS, SCHEDULED, ON_HOLD, CLOSED, CANCELLED
  shopifyFulfillmentRequestStatus  String?    // UNSUBMITTED, SUBMITTED, ACCEPTED, REJECTED, CANCELLATION_REQUESTED, etc.
  shopifyFulfillmentHoldReason     String?    // If on hold: AWAITING_PAYMENT, HIGH_RISK_OF_FRAUD, INCORRECT_ADDRESS, INVENTORY_OUT_OF_STOCK, OTHER
  shopifyFulfillmentHoldNotes      String?    // Notes about the hold

  createdAt           DateTime    @default(now())
  updatedAt           DateTime    @updatedAt
  
  // Relations
  clientId            String      @map("client_id")
  client              Client      @relation(fields: [clientId], references: [id], onDelete: Cascade)
  
  channelId           String?     @map("channel_id")
  channel             Channel?    @relation(fields: [channelId], references: [id])
  
  items               OrderItem[]
  returns             Return[]
  syncLogs            OrderSyncLog[]
  syncQueue           OrderSyncQueue[]
  shippingMismatch    ShippingMethodMismatch?
  notifications       Notification[]

  @@unique([clientId, orderId])
  @@unique([clientId, externalOrderId])
  @@index([orderOrigin])
  @@index([fulfillmentState])
  @@index([syncStatus])
  @@map("orders")
}

// Order Sync Log - Audit trail for all order sync operations
model OrderSyncLog {
  id              String      @id @default(cuid())
  
  // What changed
  action          String      // "create", "update", "cancel", "fulfill", "split"
  origin          SyncOrigin  // Where the change came from
  targetPlatform  String      // Where we synced to: "shopify", "woocommerce", "jtl"
  
  // Change details
  changedFields   String[]    @default([])  // List of fields that changed
  previousState   Json?                     // Previous order state
  newState        Json?                     // New order state
  
  // Result
  success         Boolean     @default(true)
  errorMessage    String?
  externalId      String?     // ID on the target platform
  
  // Timestamps
  createdAt       DateTime    @default(now())
  
  // Relations
  orderId         String      @map("order_id")
  order           Order       @relation(fields: [orderId], references: [id], onDelete: Cascade)
  
  @@index([orderId, createdAt])
  @@index([origin, targetPlatform])
  @@map("order_sync_logs")
}

// Order items
model OrderItem {
  id          String    @id @default(cuid())
  sku         String?   // SKU at time of order
  productName String?   // Product name at time of order
  quantity    Int
  unitPrice   Decimal?  @db.Decimal(12, 2)
  totalPrice  Decimal?  @db.Decimal(12, 2)
  weightInKg  Decimal?  @db.Decimal(10, 3)  // Weight per unit in kilograms

  orderId     String    @map("order_id")
  order       Order     @relation(fields: [orderId], references: [id], onDelete: Cascade)

  productId   String?   @map("product_id")
  product     Product?  @relation(fields: [productId], references: [id])

  @@map("order_items")
}

// Inbound Delivery
model InboundDelivery {
  id                String        @id @default(cuid())
  inboundId         String        // Display inbound ID
  
  // Delivery information
  deliveryType      DeliveryType  @default(PARCEL_SERVICE)
  expectedDate      DateTime?
  arrivedDate       DateTime?
  status            InboundStatus @default(PENDING)
  
  // Quantities
  announcedQuantity Int           @default(0)
  receivedQuantity  Int?
  numberOfProducts  Int           @default(0)
  
  // Carrier information
  carrierName       String?
  trackingNumber    String?
  
  // Simulated stock feature (temporarily increases stock until confirmed)
  simulateStock     Boolean       @default(false)
  stockSimulated    Boolean       @default(false)
  
  // Notes
  notes             String?
  
  // JTL-FFN integration
  jtlDeliveryId     String?
  lastJtlSync       DateTime?
  
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  
  // Relations
  clientId          String        @map("client_id")
  client            Client        @relation(fields: [clientId], references: [id], onDelete: Cascade)
  
  items             InboundItem[]
  
  @@unique([clientId, inboundId])
  @@map("inbound_deliveries")
}

// Inbound delivery items
model InboundItem {
  id                String          @id @default(cuid())
  announcedQuantity Int             @default(0)
  receivedQuantity  Int?
  
  inboundId         String          @map("inbound_id")
  inbound           InboundDelivery @relation(fields: [inboundId], references: [id], onDelete: Cascade)
  
  productId         String          @map("product_id")
  product           Product         @relation(fields: [productId], references: [id])
  
  @@map("inbound_items")
}

// Return (Custom module - with optional JTL-FFN integration)
// No-Limits is the RETURN MASTER - returns are event-driven, not editable objects
model Return {
  id                  String          @id @default(cuid())
  returnId            String          // Display return ID
  externalOrderId     String?         // Reference to original order
  externalReturnId    String?         // External refund/return ID from channel
  internalReturnId    String?         // Internal reference
  
  // ===== ORIGIN & AUTHORITY TRACKING =====
  // Return initiation: Can start in Shopify, Platform, or Warehouse
  // Return master: Your Platform (because FFN returns are unreliable, Shopify lacks warehouse context)
  returnOrigin        SyncOrigin      @default(NOLIMITS)   // Where return was initiated
  
  // Return information
  returnDate          DateTime        @default(now())
  status              ReturnStatus    @default(RECEIVED)
  
  // ===== INSPECTION (No-Limits/Warehouse Owned) =====
  // Physical inspection result is owned by your platform
  inspectionResult    InspectionResult @default(PENDING)
  inspectedAt         DateTime?
  inspectedById       String?         @map("inspected_by_id")
  
  // Restock decision (No-Limits owned)
  restockEligible     Boolean?        // Determined after inspection
  restockQuantity     Int             @default(0)
  restockDecidedAt    DateTime?
  restockDecidedById  String?         @map("restock_decided_by_id")
  restockReason       String?
  
  // Damage/Defect tracking
  hasDamage           Boolean         @default(false)
  damageDescription   String?
  hasDefect           Boolean         @default(false)
  defectDescription   String?
  
  // AI recognition results
  aiRecognized        Boolean         @default(false)
  aiConfidence        Float?
  aiMatchedOrderId    String?         // Order ID matched by AI
  aiMatchedCustomer   String?         // Customer name matched by AI
  isUnknownReturn     Boolean         @default(false)  // Mark for admin review
  
  // Customer information (from AI or manual entry)
  customerName        String?
  customerEmail       String?
  customerPhone       String?
  customerAddress     String?
  
  // Return reason and notes
  reason              String?         // Customer's stated reason
  reasonCategory      String?         // Categorized reason (e.g., "damaged", "wrong_item", "changed_mind")
  information         String?
  notes               String?         // Internal notes
  warehouseNotes      String?         // Warehouse-specific notes
  
  // ===== REPLACEMENT LOGIC (No-Limits Owned) =====
  triggerReplacement  Boolean         @default(false)
  replacementOrderId  String?         @map("replacement_order_id")
  
  // ===== REFUND SYNC (Commerce Platform) =====
  // Refund details are synced back to commerce platform
  refundAmount        Decimal?        @db.Decimal(12, 2)
  refundCurrency      String          @default("EUR")
  refundSynced        Boolean         @default(false)
  refundSyncedAt      DateTime?
  refundExternalId    String?         // Refund ID in commerce platform
  
  // JTL-FFN integration
  jtlReturnId         String?         // JTL-FFN Return ID
  lastJtlSync         DateTime?
  
  // ===== SYNC TRACKING =====
  syncStatus          SyncStatus      @default(PENDING)
  lastSyncedToCommerce DateTime?      // When synced to Shopify/WooCommerce
  commerceSyncError   String?
  
  // Finalization - return is complete and cannot be edited
  finalizedAt         DateTime?
  finalizedById       String?         @map("finalized_by_id")
  
  // Processing information
  processedAt         DateTime?
  processedById       String?         @map("processed_by_id")
  processedBy         User?           @relation("ProcessedBy", fields: [processedById], references: [id])
  
  createdAt           DateTime        @default(now())
  updatedAt           DateTime        @updatedAt
  
  // Relations
  clientId            String?         @map("client_id")
  client              Client?         @relation(fields: [clientId], references: [id], onDelete: Cascade)
  
  orderId             String?         @map("order_id")
  order               Order?          @relation(fields: [orderId], references: [id])
  
  channelId           String?         @map("channel_id")
  
  items               ReturnItem[]
  images              ReturnImage[]
  syncLogs            ReturnSyncLog[]
  
  @@index([returnOrigin])
  @@index([inspectionResult])
  @@index([syncStatus])
  @@map("returns")
}

// Return Sync Log - Audit trail for all return sync operations
model ReturnSyncLog {
  id              String      @id @default(cuid())
  
  // What changed
  action          String      // "create", "inspect", "restock", "refund", "finalize"
  origin          SyncOrigin  // Where the change came from
  targetPlatform  String      // Where we synced to: "shopify", "woocommerce"
  
  // Change details
  previousState   Json?       // Previous return state
  newState        Json?       // New return state
  inspectionData  Json?       // Inspection details if applicable
  
  // Result
  success         Boolean     @default(true)
  errorMessage    String?
  externalId      String?     // ID on the target platform
  
  // Timestamps
  createdAt       DateTime    @default(now())
  
  // Relations
  returnId        String      @map("return_id")
  return          Return      @relation(fields: [returnId], references: [id], onDelete: Cascade)
  
  @@index([returnId, createdAt])
  @@index([origin, targetPlatform])
  @@map("return_sync_logs")
}

// Return items - Each item has its own inspection
model ReturnItem {
  id            String            @id @default(cuid())
  sku           String?           // SKU at time of return
  productName   String?           // Product name for reference
  quantity      Int               @default(1)
  
  // Per-item inspection (No-Limits/Warehouse owned)
  condition     ProductCondition  @default(GOOD)
  disposition   ReturnDisposition @default(PENDING_DECISION)
  
  // Item-level inspection details
  inspectedQuantity     Int       @default(0)
  restockableQuantity   Int       @default(0)
  damagedQuantity       Int       @default(0)
  defectiveQuantity     Int       @default(0)
  
  // Item-level notes
  notes         String?
  damageNotes   String?           // Description of damage
  defectNotes   String?           // Description of defect
  
  // Expected vs received tracking
  expectedQuantity      Int?      // From return request
  receivedQuantity      Int?      // Actually received
  discrepancyReason     String?   // If expected != received
  
  returnId      String            @map("return_id")
  return        Return            @relation(fields: [returnId], references: [id], onDelete: Cascade)
  
  productId     String?           @map("product_id")
  product       Product?          @relation(fields: [productId], references: [id])
  
  images        ReturnItemImage[]
  
  @@map("return_items")
}

// Return images (warehouse photos)
model ReturnImage {
  id          String    @id @default(cuid())
  url         String
  description String?
  uploadedAt  DateTime  @default(now())
  
  returnId    String    @map("return_id")
  return      Return    @relation(fields: [returnId], references: [id], onDelete: Cascade)
  
  @@map("return_images")
}

// Return item images (per-item photos)
model ReturnItemImage {
  id            String      @id @default(cuid())
  url           String
  description   String?
  uploadedAt    DateTime    @default(now())
  
  returnItemId  String      @map("return_item_id")
  returnItem    ReturnItem  @relation(fields: [returnItemId], references: [id], onDelete: Cascade)
  
  @@map("return_item_images")
}

// Chat Room (One per customer)
model ChatRoom {
  id            String            @id @default(cuid())
  name          String?
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt
  
  // One chat room per client
  clientId      String            @unique @map("client_id")
  client        Client            @relation(fields: [clientId], references: [id], onDelete: Cascade)
  
  messages      ChatMessage[]
  participants  ChatParticipant[]
  
  @@map("chat_rooms")
}

// Chat participants
model ChatParticipant {
  id          String    @id @default(cuid())
  joinedAt    DateTime  @default(now())
  lastReadAt  DateTime?
  isOnline    Boolean   @default(false)
  
  chatRoomId  String    @map("chat_room_id")
  chatRoom    ChatRoom  @relation(fields: [chatRoomId], references: [id], onDelete: Cascade)
  
  userId      String    @map("user_id")
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([chatRoomId, userId])
  @@map("chat_participants")
}

// Chat Message
model ChatMessage {
  id                  String          @id @default(cuid())
  content             String
  status              MessageStatus   @default(SENT)
  
  // For warehouse free-text messages that need admin approval
  isPredefined        Boolean         @default(false)
  needsApproval       Boolean         @default(false)
  approvedAt          DateTime?
  approvedById        String?
  
  // Attachment support
  attachmentUrl       String?
  attachmentType      String?
  
  createdAt           DateTime        @default(now())
  updatedAt           DateTime        @updatedAt
  
  // Relations
  chatRoomId          String          @map("chat_room_id")
  chatRoom            ChatRoom        @relation(fields: [chatRoomId], references: [id], onDelete: Cascade)
  
  senderId            String          @map("sender_id")
  sender              User            @relation("SentMessages", fields: [senderId], references: [id])
  
  // Task creation from message
  createdTask         Task?           @relation("TaskFromMessage")
  
  @@map("chat_messages")
}

// Predefined Responses (for warehouse staff)
model PredefinedResponse {
  id          String    @id @default(cuid())
  title       String
  content     String
  category    String?
  isActive    Boolean   @default(true)
  sortOrder   Int       @default(0)
  
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  @@map("predefined_responses")
}

// Task
model Task {
  id              String        @id @default(cuid())
  taskId          String        // Display task ID
  title           String
  description     String?
  
  type            TaskType      @default(OTHER)
  priority        TaskPriority  @default(LOW)
  status          TaskStatus    @default(OPEN)
  
  // AI suggestion flag
  aiSuggested     Boolean       @default(false)
  aiConfirmed     Boolean?      // null = pending, true = confirmed, false = rejected
  
  // Notify customer when task created
  notifyCustomer  Boolean       @default(false)
  
  dueDate         DateTime?
  completedAt     DateTime?
  
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  
  // Relations
  clientId        String?       @map("client_id")
  client          Client?       @relation(fields: [clientId], references: [id])
  
  assigneeId      String?       @map("assignee_id")
  assignee        User?         @relation("AssignedTasks", fields: [assigneeId], references: [id])
  
  creatorId       String        @map("creator_id")
  creator         User          @relation("CreatedTasks", fields: [creatorId], references: [id])
  
  // Task created from chat message
  messageId       String?       @unique @map("message_id")
  fromMessage     ChatMessage?  @relation("TaskFromMessage", fields: [messageId], references: [id])

  // Task-specific chat messages
  messages        TaskMessage[]

  @@map("tasks")
}

// Task Message (for task-specific chat between admin/employees)
model TaskMessage {
  id          String    @id @default(cuid())
  content     String
  createdAt   DateTime  @default(now())

  // Relations
  taskId      String    @map("task_id")
  task        Task      @relation(fields: [taskId], references: [id], onDelete: Cascade)

  senderId    String    @map("sender_id")
  sender      User      @relation(fields: [senderId], references: [id])

  @@index([taskId, createdAt])
  @@map("task_messages")
}

// Audit Log (for critical operations)
model AuditLog {
  id          String    @id @default(cuid())
  action      String    // e.g., "CREATE_ORDER", "UPDATE_PRODUCT", "LOGIN"
  entityType  String    // e.g., "Order", "Product", "User"
  entityId    String?
  
  // Change details
  oldValue    Json?
  newValue    Json?
  
  // Request metadata
  ipAddress   String?
  userAgent   String?
  
  createdAt   DateTime  @default(now())
  
  // Who performed the action
  userId      String?   @map("user_id")
  user        User?     @relation(fields: [userId], references: [id])
  
  @@index([entityType, entityId])
  @@index([createdAt])
  @@map("audit_logs")
}

// Shipping Method configuration - JTL FFN shipping methods
model ShippingMethod {
  id                  String    @id @default(cuid())
  name                String    // e.g., "DHL package", "DHL Express"
  carrier             String    // e.g., "DHL", "UPS", "FedEx", "Hermes"
  code                String    @unique // Internal code
  
  // JTL FFN specific fields
  jtlShippingMethodId String?   @unique // JTL FFN ID like "FULF0A0001"
  jtlFulfillerId      String?   // JTL FFN Fulfiller ID like "FULF"
  jtlShippingType     String?   // Standard, Expedited, NextDay, SecondDay, SameDay
  jtlCarrierCode      String?   // Carrier code from JTL
  jtlCarrierName      String?   // Carrier name from JTL
  trackingUrlSchema   String?   // URL pattern for tracking, e.g., "https://tracking.dhl.com/...?lang=de&idc=#TrackingId#"
  cutoffTime          String?   // Last time to submit for same-day shipping, e.g., "14:00"
  
  // Settings
  isActive            Boolean   @default(true)
  isDefault           Boolean   @default(false)
  
  // Pricing (optional, may come from carrier API or manual)
  basePrice           Decimal?  @db.Decimal(10, 2)
  pricePerKg          Decimal?  @db.Decimal(10, 2)
  
  // Logo
  logoUrl             String?
  
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
  
  // Relations
  mappings            ShippingMethodMapping[]
  defaultForClients   Client[]  @relation("DefaultShippingMethod")
  
  @@map("shipping_methods")
}

// Shipping Method Mapping - Maps channel shipping methods to JTL FFN shipping methods
model ShippingMethodMapping {
  id                    String          @id @default(cuid())
  
  // Channel shipping method identifier
  channelShippingCode   String          // e.g., "flat_rate", "free_shipping", "express"
  channelShippingTitle  String          // Human-readable name from channel, e.g., "Standard Shipping"
  channelType           ChannelType     // SHOPIFY or WOOCOMMERCE
  
  // JTL FFN shipping method
  shippingMethodId      String
  shippingMethod        ShippingMethod  @relation(fields: [shippingMethodId], references: [id], onDelete: Cascade)
  
  // Client-specific mapping (optional - null means global mapping)
  clientId              String?
  client                Client?         @relation("ClientShippingMappings", fields: [clientId], references: [id], onDelete: Cascade)
  
  // Channel-specific mapping (optional - for per-channel overrides)
  channelId             String?
  channel               Channel?        @relation("ChannelShippingMappings", fields: [channelId], references: [id], onDelete: Cascade)
  
  isActive              Boolean         @default(true)
  createdAt             DateTime        @default(now())
  updatedAt             DateTime        @updatedAt
  
  @@unique([channelShippingCode, channelType, clientId, channelId])
  @@index([channelShippingCode, channelType])
  @@map("shipping_method_mappings")
}

// Shipping Method Mismatch - Tracks orders with unmapped shipping methods
model ShippingMethodMismatch {
  id                    String    @id @default(cuid())
  
  // Order reference (one mismatch per order)
  orderId               String    @unique
  order                 Order     @relation(fields: [orderId], references: [id], onDelete: Cascade)
  
  // Mismatch details
  channelShippingCode   String?   // The code from the channel
  channelShippingTitle  String?   // The title from the channel (human readable)
  channelType           ChannelType
  
  // Resolution
  isResolved            Boolean   @default(false)
  resolvedAt            DateTime?
  resolvedBy            String?   // User ID who resolved
  resolutionNote        String?
  
  // Which shipping method was ultimately used
  usedShippingMethodId  String?   // JTL shipping method that was used (fallback or manual)
  usedFallback          Boolean   @default(false) // Whether client default was used
  
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  
  @@index([isResolved])
  @@map("shipping_method_mismatches")
}

// System Settings (key-value store for app configuration)
model SystemSetting {
  id          String    @id @default(cuid())
  key         String    @unique
  value       String
  description String?
  
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  @@map("system_settings")
}

// Notification types
enum NotificationType {
  SHIPPING_MISMATCH     // Shipping method mismatch detected
  ORDER_ON_HOLD         // Order put on hold due to issues
  SYNC_ERROR            // Sync operation failed
  INVENTORY_LOW         // Low inventory warning
  SYSTEM_ALERT          // General system alert
  TASK_ASSIGNED         // Task assigned to user
  INFO                  // Informational message
}

// Notification priority
enum NotificationPriority {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

// Pipeline status (for initial sync)
enum PipelineStatus {
  PENDING
  IN_PROGRESS
  PAUSED
  COMPLETED
  FAILED
}

// Pipeline step status
enum PipelineStepStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED
  SKIPPED
}

// Notifications - System and user notifications
model Notification {
  id                String              @id @default(cuid())
  
  // Notification content
  type              NotificationType
  priority          NotificationPriority @default(MEDIUM)
  title             String
  message           String
  
  // Target user (null = broadcast to all admins)
  userId            String?
  user              User?               @relation(fields: [userId], references: [id], onDelete: SetNull)
  
  // Related entities
  clientId          String?
  client            Client?             @relation(fields: [clientId], references: [id], onDelete: SetNull)
  orderId           String?
  order             Order?              @relation(fields: [orderId], references: [id], onDelete: SetNull)
  mismatchId        String?             // Reference to ShippingMethodMismatch if applicable
  
  // Metadata (JSON for additional context)
  metadata          Json?
  
  // Status
  isRead            Boolean             @default(false)
  readAt            DateTime?
  isDismissed       Boolean             @default(false)
  dismissedAt       DateTime?
  
  // Action URL (where to navigate when clicking)
  actionUrl         String?
  
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  
  @@index([userId, isRead])
  @@index([clientId])
  @@index([type])
  @@index([createdAt])
  @@map("notifications")
}

// Sync Pipeline - Tracks multi-step sync operations during client onboarding
model SyncPipeline {
  id              String          @id @default(cuid())
  channelId       String          @map("channel_id")
  channel         Channel         @relation(fields: [channelId], references: [id], onDelete: Cascade)
  clientId        String          @map("client_id")
  status          PipelineStatus  @default(PENDING)
  currentStep     Int             @default(0)
  totalSteps      Int             @default(5)
  syncFromDate    DateTime?
  syncType        String          @default("initial") // "initial", "full", "incremental"
  progress        Float           @default(0)
  progressMessage String?
  lastError       String?
  retryCount      Int             @default(0)
  maxRetries      Int             @default(3)
  startedAt       DateTime?
  completedAt     DateTime?
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  steps           PipelineStep[]

  @@unique([channelId, syncType])
  @@index([status])
  @@index([clientId])
  @@map("sync_pipelines")
}

// Pipeline Step - Individual steps within a sync pipeline
model PipelineStep {
  id              String              @id @default(cuid())
  pipelineId      String              @map("pipeline_id")
  pipeline        SyncPipeline        @relation(fields: [pipelineId], references: [id], onDelete: Cascade)
  stepNumber      Int
  stepName        String
  stepDescription String?
  status          PipelineStepStatus  @default(PENDING)
  progress        Float               @default(0)
  itemsTotal      Int                 @default(0)
  itemsProcessed  Int                 @default(0)
  itemsFailed     Int                 @default(0)
  inputData       Json?
  outputData      Json?
  errorMessage    String?
  startedAt       DateTime?
  completedAt     DateTime?
  createdAt       DateTime            @default(now())

  @@unique([pipelineId, stepNumber])
  @@index([status])
  @@map("pipeline_steps")
}
